{
  "folderName": "utils",
  "folderPath": ".autodoc/docs/json/apps/alpha-liquidator/src/utils",
  "url": "https://github.com/mrgnlabs/mrgn-ts/.autodoc/docs/json/apps/alpha-liquidator/src/utils",
  "files": [
    {
      "fileName": "accountInfos.ts",
      "filePath": "apps/alpha-liquidator/src/utils/accountInfos.ts",
      "url": "https://github.com/mrgnlabs/mrgn-ts/apps/alpha-liquidator/src/utils/accountInfos.ts",
      "summary": "The code provided is a TypeScript module that exports two functions: `deserializeAccountInfo` and `deserializeAccountInfosMap`. The module imports two libraries: `@solana/web3.js` and `@mongodb-js/zstd`.\n\nThe `deserializeAccountInfo` function takes an `AccountInfo` object as an argument and returns a new `AccountInfo` object with the `data` property mutated. The `data` property of the input `AccountInfo` object is a string array that is compressed using the Zstandard compression algorithm. The function first decompresses the `data` property using the `decompress` function from the `@mongodb-js/zstd` library. The decompressed data is then converted to a `Buffer` object using the `Buffer.from` method. Finally, a new `AccountInfo` object is returned with the `data` property set to the decompressed `Buffer` object.\n\nThe `deserializeAccountInfosMap` function takes a `Map` object as an argument, where the keys are strings and the values are `AccountInfo` objects with string arrays as their `data` property. The function returns a new `Map` object with the same keys as the input `Map` object, but with the `AccountInfo` objects' `data` property mutated to `Buffer` objects using the `deserializeAccountInfo` function. The function first creates an empty `Map` object called `deserializedAccountInfoMap`. It then iterates over the input `Map` object using the `forEach` method and pushes a `Promise` object to the `promises` array for each `AccountInfo` object in the input `Map`. Each `Promise` object is created by calling the `deserializeAccountInfo` function with the corresponding `AccountInfo` object as an argument. The `Promise` object resolves with the mutated `AccountInfo` object, which is then added to the `deserializedAccountInfoMap` using the `set` method. The `Promise` object is also resolved with `void 0` to ensure that the `Promise` object resolves with `undefined`. Finally, the `Promise.all` method is called with the `promises` array as an argument to wait for all `Promise` objects to resolve. The `deserializedAccountInfoMap` is then returned.\n\nThis module can be used in a larger project that involves working with Solana blockchain accounts. The `deserializeAccountInfo` function can be used to decompress and convert the `data` property of an `AccountInfo` object to a `Buffer` object. The `deserializeAccountInfosMap` function can be used to apply the `deserializeAccountInfo` function to a `Map` object of `AccountInfo` objects. This can be useful when working with large amounts of compressed data in Solana accounts.",
      "questions": "1. What is the purpose of the `deserializeAccountInfo` function?\n- The `deserializeAccountInfo` function takes an `AccountInfo` object with a string array data property, decompresses the data using Zstandard compression, and returns a new `AccountInfo` object with a Buffer data property.\n\n2. What is the purpose of the `deserializeAccountInfosMap` function?\n- The `deserializeAccountInfosMap` function takes a `Map` of `AccountInfo` objects with string array data properties, deserializes each `AccountInfo` object using the `deserializeAccountInfo` function, and returns a new `Map` of `AccountInfo` objects with Buffer data properties.\n\n3. Why is the `data` property of the `AccountInfo` object mutated in the `deserializeAccountInfo` function?\n- The `data` property of the `AccountInfo` object is purposely mutated to a Buffer object because it is faster to work with than a string array."
    },
    {
      "fileName": "chunks.ts",
      "filePath": "apps/alpha-liquidator/src/utils/chunks.ts",
      "url": "https://github.com/mrgnlabs/mrgn-ts/apps/alpha-liquidator/src/utils/chunks.ts",
      "summary": "The code in this file provides a function called `chunkedGetRawMultipleAccountInfos` that fetches multiple Solana account infos in chunks. The function takes in a `Connection` object, an array of public keys (`pks`), and two optional parameters: `batchChunkSize` and `maxAccountsChunkSize`. The function returns a Promise that resolves to a tuple containing the context slot and a Map of account info objects.\n\nThe function first creates an empty `Map` object called `accountInfoMap` and sets the `contextSlot` variable to 0. It then uses the `chunks` function to split the `pks` array into smaller arrays of size `batchChunkSize`. For each batch of public keys, the function further splits them into smaller arrays of size `maxAccountsChunkSize`. It then constructs an array of objects, where each object contains a `methodName` property set to `\"getMultipleAccounts\"` and an `args` property that is an array of arguments to be passed to the `getMultipleAccounts` method. The `args` array contains the `pubkeys` array, the `commitment` object imported from the `connection` module, and a string `\"base64+zstd\"` that specifies the encoding format for the returned data.\n\nThe function then uses `Promise.all` to execute the `getMultipleAccounts` method for each batch of public keys. It first constructs an array of batch objects using the `chunks` function and the `map` method. It then calls the `_rpcBatchRequest` method of the `Connection` object with the batch array as its argument. The `_rpcBatchRequest` method returns a Promise that resolves to an array of `Result` objects. The function extracts the `context.slot` property from each `Result` object and sets the `contextSlot` variable to the maximum value. It then extracts the `value` property from each `Result` object and concatenates them into a single array. The resulting array contains `AccountInfo` objects and `null` values.\n\nFinally, the function iterates over the `accountInfos` array and adds each non-null `AccountInfo` object to the `accountInfoMap` object using the corresponding public key as the key. It then returns the tuple containing the `contextSlot` and `accountInfoMap`.\n\nThis function can be used to fetch multiple Solana account infos efficiently by splitting the public keys into smaller batches and using the `_rpcBatchRequest` method to fetch them in parallel. The function also supports chunking the public keys and using a faster encoding format (`\"base64+zstd\"`) to reduce the amount of data transferred over the network. Here is an example usage of the function:\n\n```\nimport { Connection } from \"@solana/web3.js\";\nimport { chunkedGetRawMultipleAccountInfos } from \"./mrgn-ts\";\n\nconst connection = new Connection(\"https://api.mainnet-beta.solana.com\");\n\nconst pks = [\"<public key 1>\", \"<public key 2>\", \"<public key 3>\"];\n\nchunkedGetRawMultipleAccountInfos(connection, pks).then(([contextSlot, accountInfoMap]) => {\n  console.log(`Context slot: ${contextSlot}`);\n  console.log(`Account info map: ${JSON.stringify([...accountInfoMap])}`);\n});\n```",
      "questions": "1. What is the purpose of the `chunks` function?\n- The `chunks` function takes an array and a size and returns an array of arrays where each subarray has a length of `size` or less. It is likely used to split up a larger array into smaller chunks for processing.\n\n2. What is the purpose of the `chunkedGetRawMultipleAccountInfos` function?\n- The `chunkedGetRawMultipleAccountInfos` function takes a Solana connection object, an array of public keys, and two optional chunk sizes as arguments. It uses the `chunks` function to split the public keys into batches and then fetches account information for each batch using the Solana `getMultipleAccounts` method. The function returns a Promise that resolves to a tuple containing the highest slot number of all the fetched accounts and a Map of account information objects keyed by their public key.\n\n3. Why is the `base64+zstd` encoding used instead of `base64` for fetching account information?\n- The `base64+zstd` encoding is used instead of `base64` because it is faster when fetching from the Solana RPC. According to a comment in the code, `base64` was found to be 3x slower than `zstd` when fetching."
    },
    {
      "fileName": "connection.ts",
      "filePath": "apps/alpha-liquidator/src/utils/connection.ts",
      "url": "https://github.com/mrgnlabs/mrgn-ts/apps/alpha-liquidator/src/utils/connection.ts",
      "summary": "This code is a module that exports a `connection` object used to connect to a Solana blockchain node. It uses the `@solana/web3.js` library to create a `Connection` object and sets the `commitment` level to \"confirmed\". It also uses the `fetch-retry` library to create a `fetchWithRetry` function that retries failed HTTP requests up to 3 times with a delay of 100ms between retries. Finally, it exports a `connection` object that is created by calling the `createConnection` function.\n\nThe `connection` object can be used to interact with the Solana blockchain node, such as querying account balances, sending transactions, and subscribing to events. The `commitment` level determines how many confirmations a transaction needs before it is considered final. Setting it to \"confirmed\" means that the transaction must be included in a confirmed block.\n\nThe `fetchWithRetry` function is used to make HTTP requests to the Solana node. It retries failed requests up to 3 times to handle temporary network errors. This is important because Solana transactions are time-sensitive and need to be processed quickly.\n\nThe `createConnection` function creates a new `Connection` object with the specified `RPC_ENDPOINT` and `commitment` level. It also sets the `fetch` option to use the `fetchWithRetry` function. This ensures that all HTTP requests made by the `Connection` object are retried if they fail.\n\nHere is an example of how this module can be used:\n\n```typescript\nimport { connection } from \"mrgn-ts\";\n\nasync function getBalance(publicKey: PublicKey): Promise<number> {\n  const balance = await connection.getBalance(publicKey, commitment);\n  return balance;\n}\n```\n\nIn this example, the `getBalance` function uses the `connection` object to query the balance of a Solana account identified by `publicKey`. The `commitment` level is passed as an argument to ensure that the balance is final and confirmed. The function returns the account balance as a number.",
      "questions": "1. What is the purpose of the `Commitment` and `Connection` imports from `@solana/web3.js`?\n- The `Commitment` and `Connection` imports are likely used for interacting with the Solana blockchain network.\n\n2. What is the purpose of the `fetchRetry` and `fetch` imports?\n- The `fetchRetry` and `fetch` imports are likely used for making HTTP requests, with `fetchRetry` providing retry functionality.\n\n3. What is the purpose of the `env_config` import from \"../config\"?\n- The `env_config` import is likely used for accessing environment variables or configuration settings specific to the project."
    },
    {
      "fileName": "redis.ts",
      "filePath": "apps/alpha-liquidator/src/utils/redis.ts",
      "url": "https://github.com/mrgnlabs/mrgn-ts/apps/alpha-liquidator/src/utils/redis.ts",
      "summary": "The code above imports the Redis library from the \"ioredis\" package and creates a Redis client instance named \"redis\". Redis is an in-memory data structure store that can be used as a database, cache, and message broker. \n\nThe Redis client instance is configured with the host and port of the Redis server, which in this case is set to \"localhost\" and \"6379\" respectively. Additionally, a connectTimeout of 500 milliseconds is set, which means that if the client is unable to connect to the Redis server within that time, it will throw an error.\n\nThis code is likely used in the larger mrgn-ts project to establish a connection to a Redis server and perform operations such as storing and retrieving data. For example, the following code snippet shows how the Redis client instance can be used to set a key-value pair in Redis:\n\n```\nredis.set(\"myKey\", \"myValue\", (err, result) => {\n  if (err) {\n    console.error(err);\n  } else {\n    console.log(result); // \"OK\"\n  }\n});\n```\n\nIn this example, the `set` method is called on the Redis client instance with the key \"myKey\" and the value \"myValue\". The callback function is executed once the operation is complete, and any errors are logged to the console. If the operation is successful, the result \"OK\" is logged to the console.\n\nOverall, this code is a crucial part of the mrgn-ts project as it enables the project to interact with a Redis server and perform various operations on the data stored in it.",
      "questions": "1. **What is the purpose of this code?**\\\nA smart developer might want to know what this code is doing and what its purpose is within the mrgn-ts project. Based on the code, it appears to be importing the Redis library and creating a new Redis instance with specific configuration options.\n\n2. **Why is the Redis library being used in this project?**\\\nA smart developer might want to know why the mrgn-ts project is using Redis and what specific functionality it provides. Without additional context, it's unclear what role Redis plays in the project.\n\n3. **What is the significance of the configuration options used when creating the Redis instance?**\\\nA smart developer might want to know why the specific configuration options (host, port, connectTimeout) were chosen when creating the Redis instance. Understanding the reasoning behind these choices could provide insight into the project's requirements and constraints."
    },
    {
      "fileName": "wait.ts",
      "filePath": "apps/alpha-liquidator/src/utils/wait.ts",
      "url": "https://github.com/mrgnlabs/mrgn-ts/apps/alpha-liquidator/src/utils/wait.ts",
      "summary": "The `wait` function in this code is a utility function that returns a Promise that resolves after a specified amount of time. The function takes in a single argument, `time`, which is a number representing the amount of time to wait in milliseconds. \n\nThis function can be used in a variety of scenarios where a delay is needed, such as in animations or network requests. For example, if we wanted to delay the execution of a function by 1 second, we could use the `wait` function like this:\n\n```\nasync function delayedFunction() {\n  console.log('Starting function');\n  await wait(1000);\n  console.log('Function finished');\n}\n\ndelayedFunction();\n```\n\nIn this example, the `delayedFunction` logs a message, waits for 1 second using the `wait` function, and then logs another message. The `await` keyword is used to wait for the Promise returned by `wait` to resolve before continuing with the rest of the function.\n\nOverall, the `wait` function is a simple but useful utility function that can be used in a variety of scenarios where a delay is needed.",
      "questions": "1. **What is the purpose of this function?** \nA smart developer might want to know what this function does and how it can be used in the project. Based on the code, it seems that the function is used to create a delay or pause in the execution of code for a specified amount of time.\n\n2. **What is the expected input for the `time` parameter?** \nA smart developer might want to know what type of value can be passed as the `time` parameter. Based on the code, it seems that the parameter should be a number representing the amount of time to wait in milliseconds.\n\n3. **How is this function used in the project?** \nA smart developer might want to know where this function is used in the project and how it fits into the overall functionality. Without more context, it's difficult to determine how this function is used in the project."
    }
  ],
  "folders": [],
  "summary": "The `utils` folder in the `alpha-liquidator` app of the `mrgn-ts` project contains several TypeScript modules that provide utility functions for working with Solana blockchain accounts, Redis servers, and other common tasks. \n\nThe `accountInfos.ts` module exports two functions, `deserializeAccountInfo` and `deserializeAccountInfosMap`, that can be used to decompress and convert the `data` property of `AccountInfo` objects to `Buffer` objects. These functions are useful when working with large amounts of compressed data in Solana accounts. The `chunks.ts` module provides a function, `chunkedGetRawMultipleAccountInfos`, that fetches multiple Solana account infos efficiently by splitting the public keys into smaller batches and using the `_rpcBatchRequest` method to fetch them in parallel. This function also supports chunking the public keys and using a faster encoding format (`\"base64+zstd\"`) to reduce the amount of data transferred over the network. \n\nThe `connection.ts` module exports a `connection` object that can be used to interact with a Solana blockchain node, such as querying account balances, sending transactions, and subscribing to events. The `commitment` level determines how many confirmations a transaction needs before it is considered final. The `fetchWithRetry` function is used to make HTTP requests to the Solana node and retries failed requests up to 3 times to handle temporary network errors.\n\nThe `redis.ts` module imports the Redis library from the \"ioredis\" package and creates a Redis client instance named \"redis\". This client instance is configured with the host and port of the Redis server and can be used to perform operations such as storing and retrieving data.\n\nThe `wait.ts` module provides a utility function, `wait`, that returns a Promise that resolves after a specified amount of time. This function can be used in a variety of scenarios where a delay is needed, such as in animations or network requests.\n\nOverall, these modules provide essential utility functions for working with Solana blockchain accounts, Redis servers, and other common tasks. They can be used in the larger `mrgn-ts` project to perform various operations on the data stored in Solana accounts and Redis servers. Here are some examples of how these modules can be used:\n\n```typescript\nimport { connection } from \"mrgn-ts\";\n\nasync function getBalance(publicKey: PublicKey): Promise<number> {\n  const balance = await connection.getBalance(publicKey, commitment);\n  return balance;\n}\n```\n\nIn this example, the `getBalance` function uses the `connection` object to query the balance of a Solana account identified by `publicKey`. The `commitment` level is passed as an argument to ensure that the balance is final and confirmed. The function returns the account balance as a number.\n\n```typescript\nimport { redis } from \"mrgn-ts\";\n\nredis.set(\"myKey\", \"myValue\", (err, result) => {\n  if (err) {\n    console.error(err);\n  } else {\n    console.log(result); // \"OK\"\n  }\n});\n```\n\nIn this example, the `set` method is called on the Redis client instance with the key \"myKey\" and the value \"myValue\". The callback function is executed once the operation is complete, and any errors are logged to the console. If the operation is successful, the result \"OK\" is logged to the console.",
  "questions": ""
}
